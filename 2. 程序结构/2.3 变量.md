> [!note] 
> 声明变量的通用形式： `var name type = expression`
> 1. `type`和`expression` 可以省略其中一个，但不能都省略。（如果类型省略，则类型将由初始化表达式推导决定；如果省略初始化表达式，其初始值是对应类型的零值）
> 2. 短变量声明： `name := expression`。name 的类型由 expression 的类型决定
> 3. 指针：
>    ``` go
> 	   package main
> 	   import "fmt"
> 		
> 		func main(){
> 		   x := 1
> 		   p := &x               // p 是 *int 类型
> 		   fmt.Println(*p)    // "1"
> 		   *p = 2                // *p 表示 p 指向的变量
> 		   fmt.Println(x)    // "2"
> 		}
>    ```
> 	`&`： 取地址操作符
> 	`*`： 取值，
> 	`*int`: 整型指针
> 	指针是可以比较的，当且仅当两个指针指向同一个变量或者两者都是 nil 的情况下才相等
> 4. new 函数：`new(T)` 是另一种创建变量的方式。


- “零值”（Zero Value）：在 Go 语言中，每个数据类型都有一个默认的初始值，这个初始值被称为“零值”（Zero Value）。零值是变量在声明时未显式赋值的情况下自动赋予的值。不同数据类型的零值如下：
	基本数据类型的零值
	1. **布尔类型（bool）**：
	    - 零值：`false`
	2. **整数类型（int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, uintptr）**：
	    - 零值：`0`
	3. **浮点数类型（float32, float64）**：
	    - 零值：`0.0`
	4. **复数类型（complex64, complex128）**：复数由实部和虚部组成，通常表示为 `a + bi`，其中 `a` 是实部，`b` 是虚部，`i` 是虚数单位
	    - 零值：`0 + 0i`
	5. **字符串类型（string）**：
	    - 零值：`""`（空字符串）
	6. **指针类型（*T）**：
	    - 零值：`nil`

	复合数据类型的零值
	1. **数组（array）**：
	    - 零值：数组中的每个元素都是其对应类型的零值。
	    - 例如：`var arr [3]int` 的零值是 `[0, 0, 0]`。
	2. **切片（slice）**：
	    - 零值：`nil`
	    - 例如：`var s []int` 的零值是 `nil`。
	3. **映射（map）**：
	    - 零值：`nil`
	    - 例如：`var m map[string]int` 的零值是 `nil`。
	4. **通道（channel）**：
	    - 零值：`nil`
	    - 例如：`var ch chan int` 的零值是 `nil`。
	5. **函数（function）**：
	    - 零值：`nil`
	    - 例如：`var f func() int` 的零值是 `nil`。
	6. **接口（interface）**：
	    - 零值：`nil`
	    - 例如：`var i interface{}` 的零值是 `nil`。
	7. **结构体（struct）**：
	    - 零值：结构体中的每个字段都是其对应类型的零值。
	    - 例如：
	        ``` go
			type Person struct {
	            Name string
	            Age  int
	        }
	        var p Person
			```
	        零值是 `Person{Name: "", Age: 0}`。

- **逃逸分析（Escape Analysis）** 变量的生命周期：
	**变量的生命周期**：局部变量的生命周期是动态的，每次执行声明语句时创建一个新的实体，变量一直生存到它变得 **不可访问**，这时它占用的存储空间被回收。变量的生命周期是通过它是否可达来确定的，所以局部变量可在包含它的循环的一次迭代之外继续存活。
	编译器选择使用堆还是选择栈不是基于使用`var`或`new`关键字来确定的， 而是通过逃逸分析（Escape Analysis）来决定变量是分配在栈（stack）上还是堆（heap）上。
  逃逸分析是 Go 编译器的一项优化技术，用于确定变量是否需要在堆（heap）上分配内存，而不是在栈（stack）上分配。逃逸分析的主要目的是减少堆分配的开销，提高程序的性能。

	逃逸分析的工作原理
	1. **栈分配**：
	    - 如果变量在函数内部使用，并且不会被函数外部引用，编译器会将其分配在栈上。栈上的变量在函数返回时会自动释放，不会造成内存泄漏。
	2. **堆分配**：
	    - 如果变量在函数外部被引用（例如，返回变量的地址），编译器会将其分配在堆上。堆上的变量由垃圾回收器（GC）管理，确保在不再使用时被正确回收。
		```go
		
		package main
		
		import "fmt"
		
		func createPointer() *int {
		    var x int = 42
		    return &x
		}
		
		func main() {
		    p := createPointer()
		    fmt.Println(*p) // 输出: 42
		}
		```
		在这个例子中，`createPointer` 函数返回了一个局部变量 `x` 的地址。根据逃逸分析，编译器会确定 `x` 需要在堆上分配内存，而不是在栈上。因此，`x` 的生命周期会延长，直到它不再被引用为止。
		为什么说函数返回局部变量的地址是安全的？
		1. **内存分配**：
		    - 如果局部变量在函数外部被引用，编译器会将其分配在堆上，而不是栈上。堆上的内存由垃圾回收器管理，确保在不再使用时被正确回收。
		2. **生命周期管理**：
		    - 逃逸分析确保了局部变量的生命周期被正确管理。即使函数返回了局部变量的地址，只要该地址仍然被引用，变量就会一直存在，不会被提前释放。
		3. **垃圾回收**：
		    - Go 语言的垃圾回收器会自动回收不再被引用的内存，避免了内存泄漏的问题。因此，即使局部变量被分配在堆上，也不需要手动释放内存。

# 知识点
1. “多重赋值”（Multiple Assignment）
   在 Go 语言中，`i, j = j, i` 这种赋值语句是同时进行的，没有先后顺序。这种赋值方式称为“并行赋值”（Parallel Assignment）或“多重赋值”（Multiple Assignment）。它允许多个变量一次性被赋值。
	并行赋值的工作原理
	在并行赋值中，右边的表达式会先被计算，然后同时赋值给左边的变量。具体步骤如下：
	1. **计算右边的表达式**：
	    - 首先，计算右边所有表达式的值。在这个例子中，`j` 和 `i` 的值会被计算出来。
	2. **赋值给左边的变量**：
	    - 然后，将计算出的值同时赋值给左边的变量。在这个例子中，`j` 的值会被赋给 `i`，`i` 的值会被赋给 `j`。
> [!question] 
> 交换 i 和 j 的值 
``` go
package main
import (
	"fmt"
)

func main(){
	i,j := 5,6    // 多变量的声明
	i, j = j,i    // 多重赋值：在多重赋值中，右边的表达式会先被计算，然后同时赋值给左边的变量。
	fmt.Println("i=",i,"j=",j)
}
```
> [!question] 
> 计算 2 个整数的最大公约数
> 
``` go
package main

import (
	"fmt"
)

func main(){
	x := 97
	y := 6
	for y != 0 {
		x,y = y, x%y
	}
	fmt.Println(y)
}
```
> [!question] 
> 计算斐波那契数列的第 n 个数
> 
``` go

```

2. `comma ok` 用于从映射（map）、通道（channel）或接口类型断言（type assertion）中获取值，并检查操作是否成功。`comma ok` 语法允许你同时获取值和一个布尔值，表示操作是否成功。`comma ok` 语法之所以能够返回一个额外的 `ok` 布尔值，是因为这些操作（如从映射中获取值、从通道中接收值、进行接口类型断言）在设计上支持多返回值。具体来说，这些操作的实现内部会返回两个值：主要结果和一个布尔值，表示操作是否成功。
	1. 从映射中获取值：`v, ok := m[key]`
	   映射的索引操作返回两个值，但如果你只使用一个变量来接收返回值，那么只会获取第一个返回值（即映射中的值），而忽略第二个返回值（即布尔值 `ok`）。eg: `v := m[key]`
	2. 从通道中接收值：`v, ok := <-ch`
	3. 接口类型断言：`v, ok := i.(T)`

3. `flag` 包提供了一种简单的方式来解析命令行参数。它允许你定义命令行标志（flags），并在程序启动时解析这些标志，以便在程序中使用。`flag` 包支持多种类型的标志，包括布尔型、整型、浮点型、字符串等。
	如何使用：
		1. 定义标志
			你可以使用 `flag` 包中的函数来定义不同类型的标志。常用的函数包括：
			- `flag.Bool()`：定义布尔型标志。
			  `func Bool(name string, value bool, usage string) *bool`
			- `flag.Int()`：定义整型标志。
				`func Int(name string, value int, usage string) *int`
			- `flag.Float64()`：定义浮点型标志。
			  `func Float64(name string, value float64, usage string) *float64`
			- `flag.String()`：定义字符串标志。
			  `func String(name string, value string, usage string) *string`
		2. 解析标志
			使用 `flag.Parse()` 函数来解析命令行参数，并将解析结果存储在定义的标志变量中。
		3. 使用标志
			解析完成后，你可以通过访问标志变量的指针来获取标志的值。
	其他功能：
		1. 非标志参数
			`flag.Args()` 函数返回解析后的非标志参数（即不带 `-` 或 `--` 前缀的参数）。
		 2. 帮助信息
			`flag` 包会自动生成帮助信息，当用户在命令行中输入 `-h` 或 `--help` 时，会显示所有标志的描述和默认值

这些函数返回一个指向标志值的指针。
> [!question] 
> 命令行参数：指针对于 flag 包是很关键的，它使用程序的命令行参数来设置整个程序内某些变量的值。
> 下面这个变种的 echo 命令使用两个可选的标识参数：-n 使 echo 忽略正常输出时结尾的额换行符，-s sep 使用 sep 替换 默认参数输出时使用空格分隔符。

``` go
package main

import (
	"fmt"
	"flag"
	"strings"
)

var n = flag.Bool("n", false, "省略尾随的换行符")
var sep = flag.String("s", " ", "分隔符")

func main(){
	flag.Parse()    // 解析 flag 标志
	fmt.Print(strings.Join(flag.Args(), *sep))    // 输出非标志参数，并使用 `*sep` 分隔符分隔
	if !*n {
		fmt.Println()    // 在前面输出的内容后面输出一个换行符
	}
}

```

4. new 函数
	表达式： `func new(Type) *Type`  
	`new` 是一个内置函数，用于分配内存并返回指向该内存的指针。`new` 函数适用于所有类型，包括基本类型、结构体、数组等。`new` 函数分配的内存会被初始化为该类型的零值。
	 `new` 与 `make` 的区别
	`new` 和 `make` 是 Go 语言中用于内存分配的两个内置函数，但它们有不同的用途：
	1. **`new`**：
	    - 用于分配内存并**返回指向该内存的指针**。
	    - 适用于所有类型，包括基本类型、结构体、数组等。
	    - 分配的内存会被初始化为该类型的零值。
	2. **`make`**：
	    - 用于分配和初始化内置引用类型（如切片、映射、通道）的内存。
	    - **返回的是类型本身，而不是指针**。
	    - 分配的内存会被初始化为非零值。
	    - `make` 只能用于创建切片、映射和通道
	    ``` go
	    package main
		import (
			"fmt"
		)
		
		func main(){
			var p = new([]int)    // `new([]int)` 分配了一个切片的内存，并返回指向该内存的指针。切片的零值是 `nil`，所以 `*p` 是 `[]`
			fmt.Println("p=", p)
			fmt.Println("*p=", *p)
			//*p = 1
			//fmt.Println("p=", p)
			//fmt.Println("*p=", *p)
			
			var q = make([]int, 5, 10)    // `make([]int, 5, 10)` 创建了一个长度为 5 的切片，并返回切片本身。切片的元素被初始化为零值 `0`，所以 `s` 是 `[0 0 0 0 0]`
			fmt.Println("q=", q)
		}
		```
