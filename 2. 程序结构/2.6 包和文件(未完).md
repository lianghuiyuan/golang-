
> [!summary] 
>  
> - 每个包都对应一个独立的名字空间。例如，在image包中的Decode函数和在unicode/utf16包中的Decode函数是不同的。要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。
> - 在Go语言中，一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。
> - 包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。
> - 每个源文件的包声明前紧跟着的注释是包注释。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中

> [!PopCount 函数] 
>  返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如何预生成辅助表格，这是编程中常用的技术）。

``` go

```
## 知识点一：包的导入
## 知识点二：包的初始化
`func init() { /*...*/ }`
- 这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。每个文件都可以包含多个init初始化函数。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序<u>**被自动调用**</u>。
- 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。

# 练习
## practice 2.1
> [!question] 
> 向 tempconv 包添加类型、常量和函数用来处理 Kelvin 绝对温度的转换，Kelvin 绝对零度是-273.15℃，Kelvin 绝对温度 1K 和摄氏度 1℃ 的单位间隔是一样的。
> 
``` go

```
## practice 2.2
> [!question] 
> 写一个通用的单位转换程序，用类似 cf 程序的方式从命令行读取参数，如果缺省的话则是从标准输入读取参数，然后做类似 Celsius 和 Fahrenheit 的单位转换，长度单位可以对应英尺和米，重量单位可以对应磅和公斤等。
> 
``` go

```
## practice 2.3
> [!question] 
> 重写 PopCount 函数，用一个循环代替单一的表达式，比较两个版本的性能。 
``` go


```
## practice 2.4
> [!question] 
> 用位移算法重写 PopCount 函数，每次测试最右边的 1bit，然后统计总数。比较和查表算法的性能差异 
``` go


```
## practice 2.5
> [!question] 
> 表达式 `x&(x-1)` 用于将 x 的最低的一个非零的 bit 位清零。使用这个算法重写 PopCount 函数，然后比较性能
``` go

```