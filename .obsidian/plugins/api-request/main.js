/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  checkFrontmatter: () => checkFrontmatter,
  checkGlobalValue: () => checkGlobalValue,
  default: () => MainAPIR
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/functions/frontmatterUtils.ts
var import_obsidian = require("obsidian");
var FRONTMATTER_REGEX = /^\n*---[^\n]*\n+(?<fm>.+?)\n+---.*/s;
function readFrontmatter(md) {
  var _a;
  const result = md.match(FRONTMATTER_REGEX);
  return (_a = result == null ? void 0 : result.groups) == null ? void 0 : _a.fm;
}
function parseFrontmatter(input) {
  if (input === void 0 || input === null) {
    throw new Error("Frontmatter not defined.");
  }
  return (0, import_obsidian.parseYaml)(input);
}

// src/functions/mdparse.js
var MarkdownParser = class {
  parse(text) {
    text = text.replace(/^(#{1,6})\s*(.*)$/gm, (match, p1, p2) => `<h${p1.length}>${p2}</h${p1.length}>`);
    text = text.replace(/^- \[ \](.*)$/gm, '<li class="todo-li"><input type="checkbox">$1</li>');
    text = text.replace(/^- \[x\](.*)$/gm, '<li class="todo-li"><input type="checkbox" checked>$1</li>');
    text = text.replace(/^\s*-\s*(.*)$/gm, "<li>$1</li>");
    text = text.replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>");
    text = text.replace(/\*(.*?)\*/g, "<em>$1</em>");
    text = text.replace(/!\[([^\]]+)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
    text = text.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
    text = text.replace(/^\s*>\s*(.*)$/gm, "<blockquote>$1</blockquote>");
    text = text.replace(/`([^`]+)`/g, "<code>$1</code>");
    text = this.mdTables(text);
    return text;
  }
  mdTables(text) {
    let table = "";
    let regCheckPipe = /(\|)/gi;
    text = text.trim();
    if (text.match(regCheckPipe)) {
      let rows = text.split("\n");
      let header = rows.shift();
      let headerCells = header.split("|").map((cell) => cell.trim()).filter((cell) => cell);
      let tableStart = "<table>\n<thead>\n";
      let tableEnd = "</thead>\n";
      let bodyStart = "<tbody>\n";
      let bodyEnd = "</tbody>\n";
      let rowStart = "<tr>\n";
      let rowEnd = "</tr>\n";
      let headerRow = rowStart + headerCells.map((cell) => `<th>${cell}</th>`).join("\n") + rowEnd;
      let bodyRows = rows.map((row) => {
        let cells = row.split("|").map((cell) => cell.trim()).filter((cell) => cell);
        return rowStart + cells.map((cell) => `<td>${cell}</td>`).join("\n") + rowEnd;
      }).join("\n");
      table += tableStart + headerRow + tableEnd + bodyStart + bodyRows + bodyEnd;
      table = table.replace(/<td>[-]+<\/td>/g, "");
      return table;
    } else {
      return text;
    }
  }
};

// src/functions/general.ts
var import_obsidian2 = require("obsidian");
function saveToID(reqID, reqText) {
  localStorage.setItem(reqID, reqText);
}
function addBtnCopy(el, copyThis) {
  const btnCopy = el.createEl("button", { cls: "copy-req", text: "copy" });
  btnCopy.addEventListener("click", function() {
    navigator.clipboard.writeText(copyThis).then(function() {
      btnCopy.blur();
      btnCopy.innerText = "copied!";
      setTimeout(function() {
        btnCopy.innerText = "copy";
      }, 2e3);
    }, function() {
      btnCopy.innerText = "Error";
    });
  });
}
function replaceOrder(stri, val) {
  let index = 0;
  let replaced = stri.replace(/{}/g, function() {
    return val[index++];
  });
  while (val.length > index) {
    if (val[index] === void 0)
      break;
    replaced += "\n" + stri.replace(/{}/g, val[index++]);
  }
  return replaced;
}
function nestedValue(data, key) {
  const keySplit = key.split("->").map((item) => item.trim());
  let value = data.json;
  for (let i = 0; i < keySplit.length; i++) {
    if (value === void 0) {
      return void 0;
    }
    value = value[keySplit[i]];
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    value = JSON.stringify(value, null, 2);
  }
  return value;
}
function toDocument(requestOptions, DataResponse, editor) {
  (0, import_obsidian2.requestUrl)(requestOptions).then((data) => {
    if (DataResponse !== "") {
      const DataResponseArray = DataResponse.split(",");
      for (let i = 0; i < DataResponseArray.length; i++) {
        const key = DataResponseArray[i].trim();
        let value = JSON.stringify(data.json[key]);
        if (key.includes("->")) {
          value = nestedValue(data, key);
          value = JSON.stringify(value);
        }
        editor.replaceSelection(value);
      }
    } else {
      editor.replaceSelection(`<div>
${data.text}
</div>
`);
    }
  }).catch((error) => {
    console.error(error);
    new import_obsidian2.Notice("Error: " + error.message);
  });
}

// src/functions/regx.ts
var num_braces_regx = /{(\d+)\.\.(\d+)}/;
var num_hyphen_regx = /(\d+-)+\d+/;
var nums_rex = /\d+/g;
var in_braces_regx = /{.*?}/g;
var varname_regx = /{{this\.([^{}]*)}}/g;
var no_varname_regx = /{{this\.|}}/g;
var key_regx = /{{(?!this\.)[^{}]*}}/g;

// src/functions/HtmlSanitizer.js
var HtmlSanitizer = class {
  constructor() {
    this._tagWhitelist = {
      "A": true,
      "ABBR": true,
      "B": true,
      "BLOCKQUOTE": true,
      "BODY": true,
      "BR": true,
      "CENTER": true,
      "CODE": true,
      "DD": true,
      "DIV": true,
      "DL": true,
      "DT": true,
      "EM": true,
      "FONT": true,
      "H1": true,
      "H2": true,
      "H3": true,
      "H4": true,
      "H5": true,
      "H6": true,
      "HR": true,
      "I": true,
      "IMG": true,
      "LABEL": true,
      "LI": true,
      "OL": true,
      "P": true,
      "PRE": true,
      "SMALL": true,
      "SOURCE": true,
      "SPAN": true,
      "STRONG": true,
      "SUB": true,
      "SUP": true,
      "TABLE": true,
      "TBODY": true,
      "TR": true,
      "TD": true,
      "TH": true,
      "THEAD": true,
      "UL": true,
      "U": true,
      "VIDEO": true
    };
    this._contentTagWhiteList = { "FORM": true, "GOOGLE-SHEETS-HTML-ORIGIN": true };
    this._attributeWhitelist = { "align": true, "color": true, "controls": true, "height": true, "href": true, "id": true, "src": true, "style": true, "target": true, "title": true, "type": true, "width": true };
    this._cssWhitelist = { "background-color": true, "color": true, "font-size": true, "font-weight": true, "text-align": true, "text-decoration": true, "width": true };
    this._schemaWhiteList = ["http:", "https:", "data:", "m-files:", "file:", "ftp:", "mailto:", "pw:"];
    this._uriAttributes = { "href": true, "action": true };
    this._parser = new DOMParser();
  }
  SanitizeHtml(input, extraSelector) {
    input = input.trim();
    if (input === "")
      return "";
    if (input === "<br>")
      return "";
    if (input.indexOf("<body") === -1)
      input = "<body>" + input + "</body>";
    let doc = this._parser.parseFromString(input, "text/html");
    if (doc.body.tagName !== "BODY")
      doc.body.remove();
    if (typeof doc.createElement !== "function")
      doc.createElement.remove();
    const makeSanitizedCopy = (node) => {
      let newNode;
      if (node.nodeType === Node.TEXT_NODE) {
        newNode = node.cloneNode(true);
      } else if (node.nodeType === Node.ELEMENT_NODE && (this._tagWhitelist[node.tagName] || this._contentTagWhiteList[node.tagName] || extraSelector && node.matches(extraSelector))) {
        if (this._contentTagWhiteList[node.tagName])
          newNode = doc.createElement("DIV");
        else
          newNode = doc.createElement(node.tagName);
        for (let i = 0; i < node.attributes.length; i++) {
          let attr = node.attributes[i];
          if (this._attributeWhitelist[attr.name]) {
            if (attr.name === "style") {
              for (let s = 0; s < node.style.length; s++) {
                let styleName = node.style[s];
                if (this._cssWhitelist[styleName])
                  newNode.style.setProperty(styleName, node.style.getPropertyValue(styleName));
              }
            } else {
              if (this._uriAttributes[attr.name]) {
                if (attr.value.indexOf(":") > -1 && !this.startsWithAny(attr.value, this._schemaWhiteList))
                  continue;
              }
              newNode.setAttribute(attr.name, attr.value);
            }
          }
        }
        for (let i = 0; i < node.childNodes.length; i++) {
          let subCopy = makeSanitizedCopy(node.childNodes[i]);
          newNode.appendChild(subCopy, false);
        }
        if ((newNode.tagName === "SPAN" || newNode.tagName === "B" || newNode.tagName === "I" || newNode.tagName === "U") && newNode.innerHTML.trim() === "") {
          return doc.createDocumentFragment();
        }
      } else {
        newNode = doc.createDocumentFragment();
      }
      return newNode;
    };
    let resultElement = makeSanitizedCopy(doc.body);
    return resultElement.innerHTML.replace(/<br[^>]*>(\S)/g, "<br>\n$1").replace(/div><div/g, "div>\n<div");
  }
  startsWithAny(str, substrings) {
    for (let i = 0; i < substrings.length; i++) {
      if (str.indexOf(substrings[i]) === 0) {
        return true;
      }
    }
    return false;
  }
  get AllowedTags() {
    return this._tagWhitelist;
  }
  get AllowedAttributes() {
    return this._attributeWhitelist;
  }
  get AllowedCssStyles() {
    return this._cssWhitelist;
  }
  get AllowedSchemas() {
    return this._schemaWhiteList;
  }
};
var sanitizer = new HtmlSanitizer();

// src/settings/settingsTab.ts
var import_obsidian3 = require("obsidian");
var APRSettings = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "APIR Settings" });
    const newApir = containerEl.createEl("details");
    newApir.createEl("summary", { text: "Click to Add Request \u21B4", cls: "summary-text" });
    new import_obsidian3.Setting(newApir).setName("Name").setDesc("Name of request").addText((text) => text.setPlaceholder("Name").setValue(this.plugin.settings.Name).onChange(async (value) => {
      if (value !== "") {
        this.plugin.settings.Name = value;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian3.Setting(newApir).setName("URL").setDesc("Endpoint to fetch data from").addText((text) => text.setPlaceholder("URL").setValue(this.plugin.settings.URL).onChange(async (value) => {
      this.plugin.settings.URL = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(newApir).setName("Method").setDesc("Select the desired method").addDropdown((dropDown) => {
      dropDown.addOption("GET", "GET");
      dropDown.addOption("POST", "POST");
      dropDown.addOption("POST", "PUT");
      dropDown.addOption("DELETE", "DELETE");
      dropDown.setValue(this.plugin.settings.MethodRequest);
      dropDown.onChange(async (value) => {
        this.plugin.settings.MethodRequest = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(newApir).setName("Body").setDesc("Data to send in the body").addTextArea((text) => text.setPlaceholder('{"data":"data"}').setValue(this.plugin.settings.DataRequest).onChange(async (value) => {
      this.plugin.settings.DataRequest = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(newApir).setName("Headers").setDesc("The headers of the request").addTextArea((text) => text.setPlaceholder('{"Content-Type": "application/json"}').setValue(this.plugin.settings.HeaderRequest).onChange(async (value) => {
      this.plugin.settings.HeaderRequest = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(newApir).setName("What to display").setDesc("Write the name of the variables you want to show (spaced by comma)").addText((text) => text.setPlaceholder("varname").setValue(this.plugin.settings.DataResponse).onChange(async (value) => {
      this.plugin.settings.DataResponse = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(newApir).addButton((button) => {
      button.setClass("btn-add-apir");
      button.setButtonText("ADD").onClick(async () => {
        const { Name } = this.plugin.settings;
        if (Name === "") {
          new import_obsidian3.Notice("Name is empty");
          return;
        }
        const { URL, MethodRequest, DataResponse, DataRequest, HeaderRequest } = this.plugin.settings;
        const { URLs } = this.plugin.settings;
        URLs.push({
          "url": URL,
          "Name": Name,
          "method": MethodRequest,
          "body": DataRequest,
          "headers": HeaderRequest,
          "DataResponse": DataResponse
        });
        await this.plugin.saveSettings();
        this.display();
        this.plugin.addCommand({
          id: "response-in-document-" + Name,
          name: "Response for api: " + Name,
          editorCallback: (editor) => {
            const rea = URLs[URLs.length - 1];
            toDocument(rea, rea.DataResponse, editor);
          }
        });
      });
    });
    containerEl.createEl("hr");
    containerEl.createEl("h2", { text: "Codeblock Settings" });
    new import_obsidian3.Setting(containerEl).setName("Text when request is Disabled").setDesc("What to show when a request is disabled").addText((text) => text.setPlaceholder("This request is disabled").setValue(this.plugin.settings.DisabledReq).onChange(async (value) => {
      this.plugin.settings.DisabledReq = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Status-bar text").setDesc("Text to display in the status bar when there are code blocks (use %d to show the number of blocks)").addText((text) => text.setPlaceholder("Count blocks: %d").setValue(this.plugin.settings.countBlocksText).onChange(async (value) => {
      if (!value.includes("%d"))
        value = "\u{1F5F2} %d";
      this.plugin.settings.countBlocksText = value;
      await this.plugin.saveSettings();
    }));
    const codeblock = containerEl.createEl("details");
    codeblock.createEl("summary", { text: "Click to Add Key/Value \u21B4", cls: "summary-text" });
    new import_obsidian3.Setting(codeblock).setName("Key").setDesc("Key of the codeblock").addText((text) => text.setPlaceholder("key").setValue(this.plugin.settings.Key).onChange(async (value) => {
      this.plugin.settings.Key = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(codeblock).setName("Value").setDesc("Value of the codeblock").addText((text) => text.setPlaceholder("value").setValue(this.plugin.settings.Value).onChange(async (value) => {
      this.plugin.settings.Value = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(codeblock).addButton((button) => {
      button.setClass("btn-add-codeblock");
      button.setButtonText("ADD").onClick(async () => {
        const { Key, Value } = this.plugin.settings;
        const { KeyValueCodeblocks } = this.plugin.settings;
        KeyValueCodeblocks.push({ "key": Key, "value": Value });
        await this.plugin.saveSettings();
        this.display();
      });
    });
    containerEl.createEl("hr");
    containerEl.createEl("h2", { text: "Manage Requests" });
    this.displayInfoApirs(containerEl);
    containerEl.createEl("hr");
    containerEl.createEl("h2", { text: "Manage Key/Values" });
    this.displayKeyValues();
  }
  displayKeyValues() {
    const { containerEl } = this;
    const { KeyValueCodeblocks } = this.plugin.settings;
    const ct = containerEl.createEl("div", { cls: "cocontainer full-width" });
    if (KeyValueCodeblocks.length > 0) {
      const tableContainer = ct.createEl("div", { cls: "table-container full-width" });
      const table = tableContainer.createEl("table", { cls: "api-table full-width" });
      const thead = table.createEl("thead");
      const headerRow = thead.createEl("tr");
      headerRow.createEl("th", { text: "Key" });
      headerRow.createEl("th", { text: "Value" });
      const tbody = table.createEl("tbody");
      KeyValueCodeblocks.forEach((u) => {
        const row = tbody.createEl("tr");
        row.createEl("td", { text: u.key });
        row.createEl("td", { text: u.value });
        row.addEventListener("click", async () => {
          const index = KeyValueCodeblocks.indexOf(u);
          KeyValueCodeblocks.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
  }
  displayInfoApirs(containerEl) {
    const { URLs } = this.plugin.settings;
    const ct = containerEl.createEl("div", { cls: "cocontainer" });
    if (URLs.length > 0) {
      const tableContainer = ct.createEl("div", { cls: "table-container" });
      const table2 = tableContainer.createEl("table", { cls: "api-table" });
      const thead2 = table2.createEl("thead");
      const headerRow2 = thead2.createEl("tr");
      headerRow2.createEl("th", { text: "Name" });
      headerRow2.createEl("th", { text: "URL" });
      const tbody2 = table2.createEl("tbody");
      URLs.forEach((u) => {
        const row = tbody2.createEl("tr");
        row.createEl("td", { text: u.Name });
        const urlCell = row.createEl("td");
        urlCell.createEl("a", { text: u.url.length > 50 ? u.url.substring(0, 50) + "..." : u.url, cls: "api-url" });
        urlCell.addEventListener("click", async () => {
          const index = URLs.indexOf(u);
          URLs.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        });
      });
    }
    containerEl.createEl("div", { cls: "table-container full-width" });
    const table = ct.createEl("table", { cls: "api-table full-width" });
    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");
    const hr = headerRow.createEl("th", { text: "ID" });
    const tbody = table.createEl("tbody");
    Object.keys(localStorage).forEach((key) => {
      if (key.startsWith("req-")) {
        const row = tbody.createEl("tr");
        const idCell = row.createEl("td", { text: key });
        idCell.addEventListener("click", async () => {
          localStorage.removeItem(key);
          this.display();
        });
      }
    });
    if (tbody.children.length === 0) {
      hr.innerText = "No response saved";
    }
  }
};

// src/settings/settingsData.ts
var DEFAULT_SETTINGS = {
  URL: "https://jsonplaceholder.typicode.com/todos/1",
  MethodRequest: "GET",
  DataRequest: "",
  HeaderRequest: '{"Content-Type": "application/json"}',
  DataResponse: "",
  URLs: [],
  Name: "",
  DisabledReq: "This request is disabled",
  Key: "",
  Value: "",
  KeyValueCodeblocks: [],
  countBlocksText: "Count blocks: %d"
};

// src/main.ts
var parser = new MarkdownParser();
function checkGlobalValue(value, settings) {
  var _a;
  const match = value.match(key_regx);
  if (match) {
    for (let i = 0; i < match.length; i++) {
      const key = match[i].replace(/{{|}}/g, "");
      value = value.replace(match[i], ((_a = settings.KeyValueCodeblocks.find((obj) => obj.key === key)) == null ? void 0 : _a.value) || "");
    }
  }
  return value;
}
function checkFrontmatter(req_prop, settings) {
  req_prop = checkGlobalValue(req_prop, settings);
  const match = req_prop.match(varname_regx);
  if (match) {
    for (let i = 0; i < match.length; i++) {
      const var_name = match[i].replace(no_varname_regx, "");
      if (var_name == "file.name") {
        req_prop = req_prop.replace(match[i], this.app.workspace.getActiveFile().basename);
        continue;
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      const markdownContent = activeView.editor.getValue();
      try {
        const frontmatterData = parseFrontmatter(readFrontmatter(markdownContent));
        req_prop = req_prop.replace(match[i], frontmatterData[var_name] || "");
      } catch (e) {
        console.error(e.message);
        new import_obsidian4.Notice("Error: " + e.message);
        return;
      }
    }
  }
  return req_prop;
}
var MainAPIR = class extends import_obsidian4.Plugin {
  async onload() {
    console.log("loading APIR");
    await this.loadSettings();
    async function updateStatusBar() {
      var _a, _b, _c;
      const statusbar = document.getElementsByClassName("status-bar-item plugin-api-request");
      while (statusbar[0]) {
        (_a = statusbar[0].parentNode) == null ? void 0 : _a.removeChild(statusbar[0]);
      }
      const markdownContent = (_b = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView)) == null ? void 0 : _b.getViewData();
      const codeBlocks = ((_c = markdownContent.match(/```req/g)) == null ? void 0 : _c.length) || 0;
      if (codeBlocks > 0) {
        const item = this.addStatusBarItem();
        const statusText = this.settings.countBlocksText.replace("%d", codeBlocks.toString());
        item.createEl("span", { text: statusText });
      }
    }
    this.registerEvent(this.app.workspace.on("file-open", (0, import_obsidian4.debounce)(updateStatusBar.bind(this), 300)));
    this.registerEvent(this.app.workspace.on("editor-change", updateStatusBar.bind(this)));
    this.addCommand({
      id: "show-response-in-modal",
      name: "Show response in Modal",
      callback: () => {
        new ShowOutputModal(this.app, this.settings.URL, this.settings.MethodRequest, this.settings.DataRequest, this.settings.HeaderRequest, this.settings.DataResponse).open();
      }
    });
    try {
      this.registerMarkdownCodeBlockProcessor("req", async (source, el) => {
        var _a, _b, _c;
        const sourceLines = source.split("\n");
        let [URL, show, saveTo, reqID, resType, maketable] = [String(), String(), String(), String(), String(), String()];
        let [notifyIf, properties] = [[String()], [String()]];
        let [method, format] = ["GET", "{}"];
        let [headers, body, reqRepeat] = [Object(), Object(), { "times": 1, "every": 1e3 }];
        const allowedMethods = ["GET", "POST", "PUT", "DELETE"];
        let render = false;
        let response_disabled;
        for (const line of sourceLines) {
          const lowercaseLine = line.toLowerCase();
          if (lowercaseLine.includes("method:")) {
            method = line.replace(/method:/i, "").toUpperCase();
            method = method.trim();
            if (!allowedMethods.includes(method)) {
              el.createEl("strong", { text: `Error: Method ${method} not supported` });
              return;
            }
          } else if (lowercaseLine.includes("notify-if:")) {
            const tempNotifyIf = line.replace(/notify-if:/i, "");
            notifyIf = tempNotifyIf.trim().split(" ");
          } else if (lowercaseLine.includes("req-repeat:")) {
            const repeat_values = line.replace(/req-repeat:/i, "").trim().split("@");
            const isValidNumber = (value) => {
              return /^\d+$/.test(value);
            };
            if (repeat_values.length === 2 && isValidNumber(repeat_values[0]) && isValidNumber(repeat_values[1])) {
              reqRepeat = { "times": parseInt(repeat_values[0]), "every": parseInt(repeat_values[1]) * 1e3 };
            } else {
              el.createEl("strong", { text: "Error: req-repeat format is not valid (use T@S)" });
              return;
            }
          } else if (lowercaseLine.includes("url:")) {
            URL = (_a = checkFrontmatter(line.replace(/url:/i, "").trim(), this.settings)) != null ? _a : "";
            if (!URL) {
              el.createEl("strong", { text: "Error: URL not found" });
              return;
            }
            if (URL && !URL.startsWith("http")) {
              URL = "https://" + URL;
            }
          } else if (lowercaseLine.includes("show:")) {
            show = (_b = checkFrontmatter(line.replace(/show:/i, "").trim(), this.settings)) != null ? _b : "";
            if (!show) {
              el.createEl("strong", { text: "Error: show value is empty" });
              return;
            }
          } else if (lowercaseLine.includes("headers:")) {
            const tempHeaders = (_c = checkFrontmatter(line.replace(/headers:/i, ""), this.settings)) != null ? _c : "";
            if (tempHeaders) {
              try {
                headers = JSON.parse(tempHeaders);
              } catch (e) {
                el.createEl("strong", { text: "Error: Headers format is not valid" });
                return;
              }
            }
          } else if (lowercaseLine.includes("body:")) {
            body = checkFrontmatter(line.replace(/body:/i, ""), this.settings);
          } else if (lowercaseLine.includes("format:")) {
            format = line.replace(/format:/i, "");
            if (!format.includes("{}")) {
              el.createEl("strong", { text: "Error: Use {} to show response in the document." });
              return;
            }
          } else if (lowercaseLine.includes("req-id:")) {
            reqID = line.replace(/id:/i, "").trim();
            if (sourceLines.includes("disabled")) {
              const idExists = localStorage.getItem(reqID);
              if (idExists) {
                response_disabled = parser.parse(idExists);
              } else {
                sourceLines.splice(sourceLines.indexOf("disabled"), 1);
              }
            }
          } else if (lowercaseLine.includes("save-to:")) {
            saveTo = line.replace(/save-to:/i, "").trim();
            if (!saveTo) {
              el.createEl("strong", { text: "Error: save-to value is empty. Please provide a filename with extension" });
              return;
            }
          } else if (lowercaseLine.includes("properties:")) {
            properties = line.replace(/properties:/i, "").replace(/\s/g, "").split(",");
          } else if (lowercaseLine.includes("res-type:")) {
            resType = line.replace(/res-type:/i, "").trim();
          } else if (lowercaseLine.includes("maketable:")) {
            maketable = line.replace(/maketable:/i, "").trim();
          }
        }
        if (sourceLines.includes("render")) {
          render = true;
        }
        ;
        for (let i = 0; i < reqRepeat.times; i++) {
          try {
            let responseData;
            if (!response_disabled) {
              responseData = await (0, import_obsidian4.requestUrl)({ url: URL, method, headers, body });
            } else {
              responseData = { json: JSON.parse(response_disabled) };
            }
            try {
              if (!responseData.headers["content-type"].includes("json") && resType !== "json") {
                try {
                  el.innerHTML = parser.parse(sanitizer.SanitizeHtml(responseData.text));
                } catch (e) {
                  new import_obsidian4.Notice("Error: " + e.message);
                  el.innerHTML = "<pre>" + sanitizer.SanitizeHtml(responseData.text) + "</pre>";
                }
                if (reqID)
                  saveToID(reqID, responseData.text);
                addBtnCopy(el, responseData.text);
                return;
              }
            } catch (e) {
              console.error(e.message);
            }
            if (saveTo) {
              try {
                await this.app.vault.create(saveTo, responseData.text);
                new import_obsidian4.Notice("Saved to: " + saveTo);
              } catch (e) {
                console.error(e.message);
                new import_obsidian4.Notice("Error: " + e.message);
              }
            }
            if (notifyIf) {
              const jsonPath = notifyIf[0];
              const symbol = notifyIf[1];
              const value = notifyIf[2];
              const int_value = parseInt(value);
              const jsonPathValue = jsonPath.split(".").reduce((acc, cv) => acc[cv], responseData.json);
              const lastValue = jsonPath.split(".").pop();
              if (symbol === ">" && jsonPathValue > int_value) {
                new import_obsidian4.Notice("APIR: " + lastValue + " is greater than " + int_value);
              } else if (symbol === "<" && jsonPathValue < int_value) {
                new import_obsidian4.Notice("APIR: " + lastValue + " is less than " + int_value);
              } else if (symbol === "=" && jsonPathValue === value) {
                new import_obsidian4.Notice("APIR: " + lastValue + " is equal to " + value);
              } else if (symbol === ">=" && jsonPathValue >= int_value) {
                new import_obsidian4.Notice("APIR: " + lastValue + " is greater than or equal to " + int_value);
              } else if (symbol === "<=" && jsonPathValue <= int_value) {
                new import_obsidian4.Notice("APIR: " + lastValue + " is less than or equal to " + int_value);
              }
            }
            if (!show) {
              if (properties.length > 0 && properties[0] !== "") {
                el.createEl("strong", { text: "Error: Properties are not allowed without SHOW" });
                return;
              }
              el.innerHTML = "<pre>" + JSON.stringify(responseData.json, null, 2) + "</pre>";
              if (reqID)
                saveToID(reqID, el.innerText);
              addBtnCopy(el, el.innerText);
            } else {
              const checkBracesRegex = show.match(in_braces_regx);
              if (checkBracesRegex) {
                if (show.includes(",")) {
                  el.createEl("strong", { text: "Error: comma is not allowed when using {}" });
                  return;
                }
                let temp_show = "";
                let range = [];
                try {
                  const rangeMatch = show.match(nums_rex);
                  if (rangeMatch) {
                    range = rangeMatch.map(Number);
                    if (range[0] > range[1]) {
                      el.createEl("strong", { text: "Error: range is not valid" });
                      return;
                    }
                  }
                } catch (e) {
                  console.error(e.message);
                }
                const numberBracesRegex = show.match(num_braces_regx);
                if (!numberBracesRegex) {
                  if (Array.isArray(responseData.json)) {
                    for (let i2 = 0; i2 < responseData.json.length; i2++) {
                      temp_show += show.replace(in_braces_regx, i2.toString()) + ", ";
                    }
                    show = temp_show;
                  } else {
                    const parts = show.split("->").map((part) => part.trim());
                    const processNestedObject = (obj, parts2) => {
                      let result = "";
                      const traverse = (current, idx) => {
                        if (idx >= parts2.length) {
                          if (typeof current === "object") {
                            current = JSON.stringify(current, null, 2);
                          }
                          if (typeof current === "string")
                            current = encodeURIComponent(current);
                          result += current + ", ";
                          return;
                        }
                        const part = parts2[idx];
                        if (part === "{..}") {
                          if (Array.isArray(current)) {
                            current.forEach((item, i2) => {
                              traverse(item, idx + 1);
                            });
                          } else {
                            el.createEl("strong", { text: "Error: {..} used on non-array element" });
                          }
                        } else if (part === "{gk}") {
                          Object.keys(current).forEach((key) => {
                            traverse(key, idx + 1);
                          });
                        } else {
                          const nextParts = part.split("&").map((p) => p.trim());
                          if (nextParts.length > 1) {
                            nextParts.forEach((p) => {
                              const subParts = p.split(".").map((sp) => sp.trim());
                              let subCurrent = current;
                              subParts.forEach((sp, subIdx) => {
                                if (subCurrent && subCurrent.hasOwnProperty(sp)) {
                                  if (subIdx === subParts.length - 1) {
                                    traverse(subCurrent[sp], idx + 1);
                                  } else {
                                    subCurrent = subCurrent[sp];
                                  }
                                } else {
                                  el.createEl("strong", { text: `Error: property ${sp} does not exist on current object` });
                                }
                              });
                            });
                          } else {
                            const subParts = part.split(".").map((sp) => sp.trim());
                            let subCurrent = current;
                            subParts.forEach((sp, subIdx) => {
                              if (subCurrent && subCurrent.hasOwnProperty(sp)) {
                                if (subIdx === subParts.length - 1) {
                                  traverse(subCurrent[sp], idx + 1);
                                } else {
                                  subCurrent = subCurrent[sp];
                                }
                              } else {
                                el.createEl("strong", { text: `Error: property ${sp} does not exist on current object` });
                              }
                            });
                          }
                        }
                      };
                      traverse(obj, 0);
                      return result;
                    };
                    temp_show = processNestedObject(responseData.json, parts);
                    show = temp_show;
                  }
                } else {
                  for (let i2 = range[0]; i2 <= range[1]; i2++) {
                    temp_show += show.replace(numberBracesRegex[0], i2.toString()) + ", ";
                  }
                  show = temp_show;
                }
                if (show.match(num_hyphen_regx)) {
                  show = show.replace(in_braces_regx, "-");
                  for (let i2 = 0; i2 < range.length; i2++) {
                    temp_show += show.replace("-", range[i2].toString()) + ", ";
                  }
                  show = temp_show;
                }
              }
              if (properties.length > 0 && properties[0] !== "") {
                const showArray = show.split(",");
                const propertiesArray = properties;
                const activeView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
                const file = activeView.file;
                await Promise.all(showArray.map(async (key, index) => {
                  const trimmedKey = key.trim();
                  let val = "";
                  if (trimmedKey.includes("->")) {
                    val = nestedValue(responseData, trimmedKey);
                  } else if (responseData.json && responseData.json[trimmedKey]) {
                    val = responseData.json[trimmedKey];
                  }
                  let propertyName = propertiesArray[index].trim();
                  if (propertyName) {
                    const match = propertyName.match(/\[\[(.*?)\]\]/);
                    if (match)
                      propertyName = match[1];
                    await this.app.fileManager.processFrontMatter(file, (existingFrontmatter) => {
                      if (typeof val === "object") {
                        Object.keys(val).forEach((key2) => {
                          if (match) {
                            val[key2] = "[[" + val[key2].toString() + "]]";
                          } else {
                            val[key2] = val[key2].toString();
                          }
                        });
                      }
                      if (match && typeof val !== "object") {
                        val = "[[" + val + "]]";
                      }
                      existingFrontmatter[propertyName] = val;
                    });
                  }
                }));
                return;
              }
              const trimAndProcessKey = (key) => {
                const trimmedKey = key.trim();
                return trimmedKey.includes("->") ? nestedValue(responseData, trimmedKey) : JSON.stringify(responseData.json[trimmedKey]) || trimmedKey;
              };
              const values = show.split(",").map(trimAndProcessKey).filter((key) => key !== "");
              let replacedText = replaceOrder(format, values);
              if (replacedText === "undefined") {
                show = show.trim();
                if (show[show.length - 1] === ",")
                  show = show.slice(0, -1);
                if (!show.includes("->"))
                  replacedText = show;
              }
              if (maketable) {
                const titles = maketable.split(",");
                const table = el.createEl("table");
                const thead = table.createEl("thead");
                const tbody = table.createEl("tbody");
                const trHead = thead.createEl("tr");
                titles.forEach((title) => {
                  const th = trHead.createEl("th");
                  th.createEl("strong", { text: title.trim() });
                });
                let trBody = tbody.createEl("tr");
                values.forEach((value, index) => {
                  if (index % titles.length === 0 && index !== 0) {
                    trBody = tbody.createEl("tr");
                  }
                  const td = trBody.createEl("td");
                  td.createEl("strong", { text: decodeURIComponent(value) });
                });
                return;
              }
              replacedText = decodeURIComponent(replacedText);
              !render ? el.createEl("pre", { text: replacedText }) : el.innerHTML = parser.parse(sanitizer.SanitizeHtml(replacedText));
              const idExists = localStorage.getItem(reqID);
              if (!idExists) {
                if (reqID)
                  saveToID(reqID, JSON.stringify(responseData));
              }
              addBtnCopy(el, replacedText);
            }
          } catch (error) {
            console.error(error);
            el.createEl("strong", { text: "Error: " + error.message });
            new import_obsidian4.Notice("Error: " + error.message);
          }
          await sleep(reqRepeat.every);
        }
        return;
      });
    } catch (e) {
      console.error(e.message);
      new import_obsidian4.Notice("Error: " + e.message);
    }
    this.addCommand({
      id: "response-in-document",
      name: "Paste response in current document",
      editorCallback: (editor) => {
        const set = this.settings;
        const requestOptions = {
          url: set.URL,
          method: set.MethodRequest,
          headers: JSON.parse(set.HeaderRequest),
          ...set.MethodRequest !== "GET" && { body: set.DataRequest }
        };
        toDocument(requestOptions, set.DataResponse, editor);
      }
    });
    for (let i = 0; i < this.settings.URLs.length; i++) {
      this.addCommand({
        id: "response-in-document-" + this.settings.URLs[i]["Name"],
        name: "Response for api: " + this.settings.URLs[i]["Name"],
        editorCallback: (editor) => {
          const rea = this.settings.URLs[i];
          toDocument(rea, this.settings.URLs[i]["DataResponse"], editor);
        }
      });
    }
    this.addSettingTab(new APRSettings(this.app, this));
  }
  onunload() {
    console.log("unloading APIR");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var ShowOutputModal = class extends import_obsidian4.Modal {
  constructor(app, URL, MethodRequest, DataRequest, HeaderRequest, DataResponse) {
    super(app);
    this.props = {
      URL,
      MethodRequest,
      DataRequest,
      HeaderRequest,
      DataResponse
    };
  }
  onOpen() {
    const { contentEl } = this;
    const { URL, MethodRequest, DataRequest, HeaderRequest, DataResponse } = this.props;
    const handleError = (error) => {
      console.error(error);
      new import_obsidian4.Notice("Error: " + error.message);
    };
    const parseAndCreate = (data) => (key) => {
      const value = DataResponse.includes("->") ? nestedValue(data, key) : data[key];
      contentEl.createEl("b", { text: key + " : " + JSON.stringify(value, null, 2) });
    };
    const requestOptions = {
      url: URL,
      method: MethodRequest,
      headers: JSON.parse(HeaderRequest),
      ...MethodRequest !== "GET" && { body: DataRequest }
    };
    (0, import_obsidian4.requestUrl)(requestOptions).then((data) => {
      if (DataResponse !== "") {
        const DataResponseArray = DataResponse.split(",");
        DataResponseArray.forEach(parseAndCreate(data));
      } else {
        contentEl.createEl("b", { text: JSON.stringify(data.json, null, 2) });
      }
    }).catch(handleError);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};


/* nosourcemap */