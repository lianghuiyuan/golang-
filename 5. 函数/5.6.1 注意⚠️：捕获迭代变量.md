> [!summary] 
> 在 Go 语言中，**捕获迭代变量** 是指在循环中定义的变量被匿名函数或闭包捕获，并在循环外部使用。由于 Go 的变量作用域规则，捕获迭代变量可能会导致意外的行为，尤其是在并发编程中。理解捕获迭代变量的机制对于编写正确的 Go 代码非常重要。
> 
### 捕获迭代变量的基本概念

在 Go 中，循环变量（如 `for` 循环中的变量）在每次迭代中会被重新赋值，但这些变量在循环外部是共享的。如果匿名函数或闭包捕获了这些变量，可能会导致意外的结果。

以下代码验证迭代变量是否还是原变量：
```go
package main

import "fmt"

func main() {
    values := []int{0, 1, 2}

    for i, v := range values {
        fmt.Printf("Iteration %d: i = %p, v = %p\n", i, &i, &v)
    }
}
```
结果（go version go1.21.3 darwin/amd64）：go1.22版本以上结果不一样
``` 
Iteration 0: i = 0xc000094000, v = 0xc000094008 
Iteration 1: i = 0xc000094000, v = 0xc000094008 
Iteration 2: i = 0xc000094000, v = 0xc000094008
```

#### 示例：捕获迭代变量的问题
``` go
package main

import (
    "fmt"
    "time"
)

func main() {
    var prints []func()

    for i := 0; i < 3; i++ {
        prints = append(prints, func() {
            fmt.Println(i)
        })
    }

    // 调用捕获的函数
    for _, print := range prints {
        print()
    }
}
```

**预期输出**：
```
0
1
2
```
实际输出：
```
3
3
3
```
**原因分析**：
- 在 `for` 循环中，变量 `i` 是共享的，每次迭代时 `i` 的值会被更新。
- <u>匿名函数捕获的是变量 `i` 的引用，而不是每次迭代时的值。</u>
- 当循环结束时，`i` 的值为 `3`，因此所有捕获的函数都会输出 `3`。

### 解决捕获迭代变量的问题

为了避免捕获迭代变量的问题，可以采取以下几种方法：

#### 1. 使用局部变量

在循环体内定义一个新的局部变量，并将其值赋给该变量。这样，匿名函数捕获的是每次迭代时的局部变量，而不是共享的循环变量。
```go
package main

import (
    "fmt"
)

func main() {
    var prints []func()

    for i := 0; i < 3; i++ {
        // 定义局部变量
        j := i
        prints = append(prints, func() {
            fmt.Println(j)
        })
    }

    // 调用捕获的函数
    for _, print := range prints {
        print()
    }
}
```

**输出**：
```
0
1
2
```
**解释**：
- 在每次迭代中，定义了一个新的局部变量 `j`，并将其值赋为 `i`。
- 匿名函数捕获的是局部变量 `j`，而不是共享的循环变量 `i`。
- 因此，每次调用捕获的函数时，输出的值是正确的。
    

#### 2. 使用闭包立即执行
在循环体内立即执行一个闭包，并将迭代变量的值传递给闭包。
```go
package main

import (
    "fmt"
)

func main() {
    var prints []func()

    for i := 0; i < 3; i++ {
        // 立即执行闭包
        func(i int) {
            prints = append(prints, func() {
                fmt.Println(i)
            })
        }(i)
    }

    // 调用捕获的函数
    for _, print := range prints {
        print()
    }
}
```

**输出**：
```
0
1
2
```
**解释**：
- 在每次迭代中，定义了一个立即执行的闭包，并将 `i` 的值传递给闭包。
- 闭包捕获的是传递的参数 `i`，而不是共享的循环变量 `i`。
- 因此，每次调用捕获的函数时，输出的值是正确的。

> [!attention] 
> ![[Pasted image 20241213115652.png]] 
> ### 关键点解释
> 
> #### 1. **Go 1.22 的变化**
> 
> 在 **Go 1.22** 之前，`for` 循环中的迭代变量是共享的，而不是每次迭代都创建新的变量。这意味着在循环中捕获迭代变量时，所有捕获的匿名函数都会引用同一个变量，导致意外的行为。
> 
> **Go 1.22** 引入了新的行为：
> 
> - **每次迭代都有自己的独立变量**：
> 
> - 在 `for` 循环中，每次迭代都会创建一个新的变量，而不是共享同一个变量。
> 
> - 这意味着在循环中捕获迭代变量时，每个匿名函数都会捕获当前迭代时的变量值，而不是共享的变量。
> 
> 
> #### 2. **Go 1.23 的变化**
> 
> 在 **Go 1.23** 中，`for-range` 循环的行为也得到了改进：
> 
> - **`for-range` 循环的迭代变量**：
> 
> - `for-range` 循环现在也会为每次迭代创建新的变量，而不是共享同一个变量。
> 
> - 这意味着在 `for-range` 循环中捕获迭代变量时，每个匿名函数都会捕获当前迭代时的变量值，而不是共享的变量。
> 
> 
> ### 示例代码
> 
> #### 1. **Go 1.22 之前的代码**
> 
> 在 **Go 1.22** 之前，`for` 循环中的迭代变量是共享的，因此捕获的匿名函数会引用同一个变量。
> ```
> var prints []func()
> for i := 0; i < 5; i++ {
> prints = append(prints, func() {
> println(i)
> })
> i++
> }
> 
> for _, p := range prints {
> p()
> }
> ```
> **输出**：
> ```
> 6
> 6
> 6
> ```
> 
> **解释**：
> 
> - 在 `for` 循环中，变量 `i` 是共享的，每次迭代时 `i` 的值会被更新。
> 
> - 匿名函数捕获的是变量 `i` 的引用，而不是每次迭代时的值。
> 
> - 当循环结束时，`i` 的值为 `6`。
> 
> - 所有捕获的匿名函数在执行时，都会访问当前的 `i` 值，即 `6`。
> 
> 
> #### 2. **Go 1.22 之后的代码**
> 
> 在 **Go 1.22** 之后，`for` 循环中的迭代变量是每次迭代创建的新变量，因此捕获的匿名函数会捕获当前迭代时的变量值。
> ``` go
> var prints []func()
> for i := 0; i < 5; i++ {
> 	prints = append(prints, func() {
> 		println(i)
> 	})
> 	i++
> }
> 
> for _, p := range prints {
> 	p()
> }
> ```
> 
> **输出**：
> ```
> 1
> 3
> 5
> ```
> 
> **解释**：
> 
> - 在 `for` 循环中，每次迭代都会创建一个新的变量 `i`。
> 
> - 匿名函数捕获的是每次迭代时的变量 `i`，而不是共享的变量。
> 
> - 因此，每次调用捕获的函数时，输出的值是正确的。
> 
> 
> ### `for-range` 循环的变化
> 
> 在 **Go 1.23** 中，`for-range` 循环的行为也得到了改进：
> 
> - **`for-range` 循环的迭代变量**：
> 
> - `for-range` 循环现在也会为每次迭代创建新的变量，而不是共享同一个变量。
> 
> - 这意味着在 `for-range` 循环中捕获迭代变量时，每个匿名函数都会捕获当前迭代时的变量值，而不是共享的变量。
> 
> 
> #### 示例代码
> ```go
> package main
> 
> import "fmt"
> 
> func main() {
> var prints []func()
> 
> values := []int{0, 1, 2}
> for _, i := range values {
> prints = append(prints, func() {
> fmt.Println(i)
> })
> }
> 
> // 调用捕获的函数
> for _, print := range prints {
> print()
> }
> }
> ```
> 
> 
> **输出**：
> ```
> 0
> 1
> 2
> ```
> 
> **解释**：
> 
> - 在 `for-range` 循环中，每次迭代都会创建一个新的变量 `i`。
> 
> - 匿名函数捕获的是每次迭代时的变量 `i`，而不是共享的变量。
> 
> - 因此，每次调用捕获的函数时，输出的值是正确的。
> 
> ### 总结
> 
> - **Go 1.22 的变化**：
> 
> - `for` 循环中的迭代变量是每次迭代创建的新变量，而不是共享同一个变量。
> 
> - 捕获迭代变量时，每个匿名函数都会捕获当前迭代时的变量值。
> 
> - **Go 1.23 的变化**：
> 
> - `for-range` 循环中的迭代变量也是每次迭代创建的新变量，而不是共享同一个变量。
> 
> - 捕获迭代变量时，每个匿名函数都会捕获当前迭代时的变量值。
> 
> 
> 通过这些变化，Go 语言修复了历史遗留问题，确保了迭代变量的正确捕获和使用，避免了意外的行为。

### 捕获迭代变量的应用场景

捕获迭代变量的问题通常出现在以下场景中：
1. **并发编程**：在并发编程中，捕获迭代变量可能会导致数据竞争或意外的结果。
2. **闭包**：在闭包中捕获迭代变量时，需要特别注意变量的作用域和生命周期。
3. **回调函数**：在回调函数中捕获迭代变量时，可能会导致意外的行为。
### 总结
- **捕获迭代变量** 是指在循环中定义的变量被匿名函数或闭包捕获，并在循环外部使用。
- **问题**：由于循环变量是共享的，捕获迭代变量可能会导致意外的结果。
- **解决方法**：
    - 使用局部变量。
    - 使用闭包立即执行。
    - 使用 `for-range` 循环。
- **应用场景**：并发编程、闭包、回调函数等。

通过理解捕获迭代变量的机制，并采取适当的解决方法，可以避免在 Go 编程中出现意外的行为，确保代码的正确性和健壮性。